name: Sync Dotfiles

on:
  # Run daily at 2 AM UTC
  schedule:
    - cron: '0 2 * * *'
  
  # Allow manual trigger
  workflow_dispatch:
  
  # Run when dotfiles repo updates (requires webhook)
  repository_dispatch:
    types: [dotfiles-updated]

jobs:
  sync-dotfiles:
    runs-on: ubuntu-latest
    permissions:
      contents: write        # Required to push commits
      pull-requests: write   # Required to create PRs

    steps:
      - name: Checkout justin-os
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Checkout dotfiles repo
        uses: actions/checkout@v5
        with:
          repository: zoro11031/dotfiles
          path: dotfiles-sync
          # Use DOTFILES_PAT if configured for private repos, otherwise use GITHUB_TOKEN
          # Falls back to GITHUB_TOKEN for public repos when DOTFILES_PAT is not configured
          token: ${{ secrets.DOTFILES_PAT || secrets.GITHUB_TOKEN }}
          
      - name: Copy updated configs
        run: |
          set -eo pipefail

          mkdir -p files/home

          shopt -s dotglob nullglob

          copied_any=false
          declare -A seen_paths

          while IFS= read -r -d '' source; do
            category="${source#dotfiles-sync/}"

            if [[ "$category" == ".git" || "$category" == ".github" ]]; then
              continue
            fi

            if [ -d "$source" ]; then
              if [[ "$category" == .* ]]; then
                dest_prefix="$category"
                rsync_dest="files/home/"
                rsync_source="$source"
              else
                dest_prefix=""
                rsync_dest="files/home/"
                rsync_source="$source/"
              fi

              echo "Syncing configs from $category"

              while IFS= read -r -d '' file; do
                rel_path="${file#"$source"/}"

                if [ -z "$rel_path" ]; then
                  continue
                fi

                if [ -n "$dest_prefix" ]; then
                  final_path="$dest_prefix/$rel_path"
                else
                  final_path="$rel_path"
                fi

                if [[ -n "${seen_paths[$final_path]}" ]]; then
                  echo "Error: path '$final_path' provided by '$category' also exists in '${seen_paths[$final_path]}'" >&2
                  exit 1
                fi

                seen_paths[$final_path]="$category"
              done < <(find "$source" -mindepth 1 \( -type f -o -type l \) -print0)

              if output=$(rsync -a --itemize-changes "$rsync_source" "$rsync_dest"); then
                if [ -n "$output" ]; then
                  echo "$output" | sed 's/^/  /'
                else
                  echo "  No differences detected for $category"
                fi
              fi

            else
              rel_path="$category"

              if [[ -n "${seen_paths[$rel_path]}" ]]; then
                echo "Error: path '$rel_path' provided by 'dotfiles root' also exists in '${seen_paths[$rel_path]}'" >&2
                exit 1
              fi

              seen_paths[$rel_path]="dotfiles root"

              echo "Copying file $category"
              dest_dir="files/home/$(dirname -- "$rel_path")"
              # If dirname returns '.', this creates files/home/.; remove trailing '/.' to get files/home/
              dest_dir="${dest_dir%/.}"
              mkdir -p "$dest_dir"
              cp -a "$source" "files/home/$rel_path"
            fi

            copied_any=true
          done < <(find dotfiles-sync -mindepth 1 -maxdepth 1 ! -name '.git' ! -name '.github' -print0 | sort -z)

          if [ "$copied_any" = false ]; then
            echo "No configuration entries found in dotfiles repository"
          fi
          
      - name: Check for changes
        id: check_changes
        run: |
          # Check for both tracked modifications and untracked files in files/home/
          # Scoped to files/home/ to ignore the dotfiles-sync checkout directory
          if [ -z "$(git status --porcelain -- files/home/)" ]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
            echo "No changes detected"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "Changes detected:"
            git status --porcelain -- files/home/
          fi
          
      - name: Create PR with changes
        if: steps.check_changes.outputs.changed == 'true'
        env:
          # Use GH_PAT if available (recommended), otherwise fall back to GITHUB_TOKEN
          # Note: GITHUB_TOKEN requires "Allow GitHub Actions to create and approve pull requests"
          # to be enabled in repository Settings → Actions → General
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          set -eo pipefail

          # Check if we're using a PAT or GITHUB_TOKEN
          if [ -z "${{ secrets.GH_PAT }}" ]; then
            echo "⚠️  Using default GITHUB_TOKEN (GH_PAT secret not configured)"
            echo "If PR creation fails, you need to either:"
            echo "  1. Add a GH_PAT secret with 'repo' or 'public_repo' scope, OR"
            echo "  2. Enable 'Allow GitHub Actions to create and approve pull requests'"
            echo "     in Settings → Actions → General"
            echo ""
          else
            echo "✓ Using GH_PAT secret for authentication"
          fi

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Capture timestamp once for consistency
          TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
          DATE_ONLY="$(date +%Y-%m-%d)"

          # Detect default branch dynamically
          DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5)
          echo "Using base branch: $DEFAULT_BRANCH"

          # Create a new branch
          BRANCH_NAME="sync-dotfiles-$TIMESTAMP"
          git checkout -b "$BRANCH_NAME"

          # Stage and commit changes
          git add files/home/

          # Generate description of changes
          PR_BODY="$RUNNER_TEMP/pr_body.md"
          echo "## Changed Files" > "$PR_BODY"
          echo "" >> "$PR_BODY"

          # Use process substitution to avoid subshell issue
          while IFS= read -r file; do
            echo "- \\\`$file\\\`" >> "$PR_BODY"
          done < <(git diff --cached --name-only)

          echo "" >> "$PR_BODY"
          echo "## Summary of Changes" >> "$PR_BODY"
          echo "" >> "$PR_BODY"
          git diff --cached --stat >> "$PR_BODY"
          echo "" >> "$PR_BODY"
          echo "---" >> "$PR_BODY"
          echo "Auto-synced from [zoro11031/dotfiles](https://github.com/zoro11031/dotfiles)" >> "$PR_BODY"

          # Commit
          git commit -m "chore: sync dotfiles from zoro11031/dotfiles"

          # Push to remote
          git push -u origin "$BRANCH_NAME"

          # Create PR
          gh pr create \
            --title "chore: sync dotfiles - $DATE_ONLY" \
            --body-file "$PR_BODY" \
            --base "$DEFAULT_BRANCH"

          # Clean up temporary file
          rm -f "$PR_BODY"
          
      - name: Cleanup
        if: always()
        run: |
          rm -rf dotfiles-sync
